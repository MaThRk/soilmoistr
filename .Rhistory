path_sm
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632"
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
# get the dates of the tiffs ----------------------------------------------
dates = gsub(".*32632/(\\d{8}).*", "\\1", paths_sm_tiffs) %>% as.Date(., "%Y%m%d")
dates
i
i = 2795
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
spatial.obj
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
j = 1
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(dates == match)
point_buffer
# load that tiff as stars object
matched_stars = read_stars(paths_sm_tiffs[[idx]])
# extract the raster value for that point
point_extraction = st_extract(matched_stars, spatial.obj) %>%
st_drop_geometry() %>%
mutate(date_sm_acquisition = match)
point_extraction
names(point_extraction)[[1]] = c("sm_values")
# put the dataframe in the values match list
values_match[[j]] = point_extraction
values_match
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
# for potentially multiple matches in that time frame
for (j in seq_along(1:length(matches))) {
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(dates == match)
# if working with point data, lets load it as stars
if (is.null(point_buffer)) {
# load that tiff as stars object
matched_stars = read_stars(paths_sm_tiffs[[idx]])
# extract the raster value for that point
point_extraction = st_extract(matched_stars, spatial.obj) %>%
st_drop_geometry() %>%
mutate(date_sm_acquisition = match)
names(point_extraction)[[1]] = c("sm_values")
# put the dataframe in the values match list
values_match[[j]] = point_extraction
} else{
# We create the buffer
# we use a polygon --> exact_extract
buf = st_buffer(spatial.obj[i, ], point_buffer)
# load the tif as raster
matched_raster = raster(paths_sm_tiffs[[i]])
# extract the cell-values --> no aggregation
if (is.null(aggre_fun)) {
poly_extraction = exact_extract(matched_raster,
buf,
force_df = TRUE) %>%
.[[1]] %>%
mutate(date_sm_acquisition = match)
values_match[[j]] = poly_extraction
} else{
# if we aggregate
poly_extraction = exact_extract(matched_raster,
buf,
fun = aggre_fun,
force_df = TRUE) %>%
mutate(date_sm_acquisition = match)
# put it in the list
values_match[[j]] = poly_extraction
}
}
}
values_match
# stack all the extracted dfs to one
values_extraction = do.call("rbind", values_match)
values_extraction
# put the df with the extracted values in the list at the first place
spatial.obj[["sm_values"]][[1]] = values_extraction
spatial.obj
res = point_extraction(spatial.obj, matches, dates, point_buffer, aggre_fun)
res
res$sm_values
class(res)
landsld[[i]] = res
values_extraction
devtools::load_all()
rm(list=c("point_extraction"))
res = point_extraction(spatial.obj, matches, dates, point_buffer, aggre_fun)
res
landsld[["sm_values"]][[i]] = res
landsld[["sm_values"]][[i]]
usethis::edit_r_profile()
path_su
usethis::edit_r_profile()
su_path
devtools::load_all()
landsld = read_sf(su_path)
landsld[["date"]] = sample(seq(as.Date('2015/01/01'), as.Date('2020/01/01'), by="day"), replace = T, nrow(landsld))
landsld = landsld[1:100,]
days_before_window = 5
days_after_window = 0
point_buffer = NULL
aggre_fun = c("mean")
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/"
# check if the landsld data is available and has a date column ------------
check_date(landsld)
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
if (type == "POINT") {
point = TRUE
} else{
point = FALSE
}
point
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
# get the dates of the tiffs ----------------------------------------------
dates = gsub(".*32632/(\\d{8}).*", "\\1", paths_sm_tiffs) %>% as.Date(., "%Y%m%d")
dates
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632"
length(path_sm)
nchar(path_sm)
path_sm[[nchar(path_sm)]]
path_sm[[nchar(path_sm)-1]]
path_sm[2]
path_sm
substr(path_sm, nchar(path_sm), nchar(path_sm))
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/"
substr(path_sm, nchar(path_sm), nchar(path_sm))
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
last_cha
last_char
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
last_char
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
path_sm
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
if (type == "POINT") {
point = TRUE
} else{
point = FALSE
}
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
paths_sm_tiffs
# get the dates of the tiffs ----------------------------------------------
dates = gsub(".*32632/(\\d{8}).*", "\\1", paths_sm_tiffs) %>% as.Date(., "%Y%m%d")
dates
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
landsld
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 1
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
plot(spatial.obj[0])
point
aggre_fun
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj, matches, dates, aggre_fun)
res
landsld[["sm_values"]][[i]] = res
rm(list=c("landsld"))
library(iffitoR)
res = get_sm_data(landsld = landsld,
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/",)
res = get_sm_data(landsld = landsld,
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/")
res
unique(res$n_matches)
unique(res$sm_values)
# check if the landsld data is available and has a date column ------------
check_date(landsld)
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
if (type == "POINT") {
point = TRUE
} else{
point = FALSE
}
point
# get the dates of the tiffs ----------------------------------------------
dates = gsub(".*32632/(\\d{8}).*", "\\1", paths_sm_tiffs) %>% as.Date(., "%Y%m%d")
dates
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 1
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
matches
i = 1795
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
matches
i = 2795
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
res = point_extraction(spatial.obj, matches, dates, point_buffer, aggre_fun)
res
landsld[["sm_values"]][[i]] = res
# go through each spatial row
for (i in seq_along(1:nrow(landsld))) {
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
# if there is a match check the raster values that we have at that location
if (length(matches) > 0) {
cat("MATCH\n")
cat(unique(landsld$n_matches))
# POINTS OR BUFFERED POINTS
if (point) {
res = point_extraction(spatial.obj, matches, dates, point_buffer, aggre_fun)
landsld[["sm_values"]][[i]] = res
} else{
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj, matches, dates, aggre_fun)
landsld[["sm_values"]][[i]] = res
}
} else{
# No Match of dates --> the values for that slide is 0
landsld[["sm_values"]][[i]] = NA
}
}
# go through each spatial row
for (i in seq_along(1:nrow(landsld))) {
# print superinformative message
n = nrow(landsld)
str = paste0(i, "/", n)
dashes = paste0(replicate(20, "-"), collapse = "")
cat("\n------------", str, dashes, "\n\n")
# get the date of the slide
date_slide = landsld[i,]$date
# range of days arounf landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = dates[dates %in% date_range_slides]
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
# if there is a match check the raster values that we have at that location
if (length(matches) > 0) {
cat("MATCH\n")
# POINTS OR BUFFERED POINTS
if (point) {
res = point_extraction(spatial.obj, matches, dates, point_buffer, aggre_fun)
landsld[["sm_values"]][[i]] = res
} else{
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj, matches, dates, aggre_fun)
landsld[["sm_values"]][[i]] = res
}
} else{
# No Match of dates --> the values for that slide is 0
landsld[["sm_values"]][[i]] = NA
}
}
landsld = landsld[1:100, ]
devtools::load_all()
res = get_sm_data(landsld = landsld, path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/")
res
unique(res$n_matches)
unique(res$sm_values)
dim(res)
dim(landsld)
res = get_sm_data(landsld = landsld, path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/")
rm(list = l())
rm(list = ls())
path_sm
usethis::edit_r_profile()
library(iffitoR)
devtools::load_all()
ls
landsld = landsld[grepl("translational"), landsld$second_level, ]
landsld = landsld[grepl("translational", landsld$second_level), ]
dim(landsld)
path_sm
usethis::edit_r_profile()
path_sm = "/mnt/CEPH_PROJECTS/Proslide/32632"
res = get_sm_data(landsld = landsld, path_sm = path_sm)
res
dim(res)
res
res
dim(res)
ls()
res %>% select
library(dplyr)
res %>% select(c(n_matches, sm_values))
res %>% select(c(n_matches, sm_values)) %>% View()
dim(landsld)
head(landsld$date)
# check if the landsld data is available and has a date column ------------
check_date(landsld)
devtools::load_all()
# check if the landsld data is available and has a date column ------------
check_date(landsld)
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
if (type == "POINT") {
point = TRUE
} else{
point = FALSE
}
point
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
paths_sm_tiffs
path_sm
sm_path
path_sm
readRenviron()
usethis::edit_r_profile()
usethis::edit_r_environ()
path_sm
readRenviron()
usethis::edit_r_makevars()
usethis::edit_r_profile()
usethis::edit_r_environ()
path_sm
path_sm
usethis::edit_r_profile()
path_sm
usethis::edit_r_profile()
usethis::edit_r_environ()
database_dir
path_sm
source("~/.Rprofile")
path_sm
landsld
landsld = landsld[grepl("translational", landsld$second_level), ]
# check if the landsld data is available and has a date column ------------
check_date(landsld)
devtools::load_all
devtools::load_all()
ls
ls()
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
if (type == "POINT") {
point = TRUE
} else{
point = FALSE
}
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
paths_sm_tiffs
# get the dates of the tiffs ----------------------------------------------
dates = gsub(".*32632/(\\d{8}).*", "\\1", paths_sm_tiffs) %>% as.Date(., "%Y%m%d")
dates
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
class(landsld)
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
landsld
landsld
rm(list = c("landsld"))
library(iffitoR)
landsld = landsld[!is.na(landsld$date),]
landsld
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
landsld
dim(landsld)
landsld = landsld[grepl("translational"), landsld$second_level, ]
landsld = landsld[grepl("translational", landsld$second_level), ]
dim(landsld)
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 1
res = get_sm_data(landsld, path_sm = path_sm)
dim(res)
unique(res$n_matches)
res$sm_values[[1]]
which(res$sm_values)
which(!is.na(res$sm_values))
res$sm_values[[3]]
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
paths_sm_tiffs
install.packages("reticulate")
y
reticulate::repl_python()
import subprocess
y
y
n
reticulate::repl_python()
