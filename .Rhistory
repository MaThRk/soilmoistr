}
landsld[["sm_values"]][[6]]
class(landsld[["sm_values"]][[6]])
dim(landsld[["sm_values"]][[6]])
i
i = 6
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
# get the date of the slide
date_slide = landsld[i,]$date
date_slide
# range of days around landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = times[dates %in% date_range_slides]
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
matches
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
class(res)
dim(res)
res
head(res)
class(res)
point_buffer
unique(res$time)
spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun
spatial.obj = spatial.obj
paths_sm_tiffs = paths_sm_tiffs
matches = matches
tracks = tracks
swaths = swaths
point_buffer = point_buffer
times = times
aggre_fun = aggre_fun
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
j= 1
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(times == match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
month = month(match)
if (nchar(month) == 1) {
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
matched_raster
plot(matched_raster)
# load the soilmoisture image as raster
matched_raster = read_stars(paths_sm_tiffs[[idx]])
plot(matched_raster)
spatial.obj = st_buffer(spatial.obj, point_buffer)
spatial.obj
plot(spatial.obj)
plot(spatial.obj[0])
s = matched_raster
plot(s)
s
s[,spatial.obj]
r = s[,spatial.obj]
plot(r)
s
s[r]
class(s)
class(r)
r
spatial.obj
s[spatial.obj]
r = s[spatial.obj]
class(r)
plot(r)
r
r[[1]]
v = r[[1]]
v
dim(v)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE)
res
class(res)
class(res[[1]])
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
res
res = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE)
dim(res)
dim(res[[1]])
class(res1)
# if we aggregate
res = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
# if we aggregate
res = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
dim(res)
j =
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
# for potentially multiple matches in that time frame
for (j in seq_along(1:length(matches))) {
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(times == match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
month = month(match)
if (nchar(month) == 1) {
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
# if we were originally using points, we must here create the buffer around that point
if (!is.null(point_buffer)) {
spatial.obj = st_buffer(spatial.obj, point_buffer)
}
# extract the cell-values --> no aggregation
if (is.null(aggre_fun)) {
res
values_match[[j]] = res
} else{
# if we aggregate
res = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
# put it in the list
values_match[[j]] = res
}
}
values_match
matches
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
# for potentially multiple matches in that time frame
for (j in seq_along(1:length(matches))) {
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(times == match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
month = month(match)
if (nchar(month) == 1) {
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
# if we were originally using points, we must here create the buffer around that point
if (!is.null(point_buffer)) {
spatial.obj = st_buffer(spatial.obj, point_buffer)
}
# extract the cell-values --> no aggregation
if (is.null(aggre_fun)) {
res
values_match[[j]] = res
} else{
# if we aggregate
res = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
# put it in the list
values_match[[j]] = res
}
}
j
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
dim(res)
matched_raster
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE)
res
j = 1
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(times == match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
month = month(match)
if (nchar(month) == 1) {
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
spatial.obj = st_buffer(spatial.obj, point_buffer)
spatial.obj
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
res
dim(res)
class(res)
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE)
res
a = res[[1]]
hist(a)
hist(a$coverage_fraction)
plot(matched_raster)
paths_sm_tiffs[[idx]]
st = read_stars((paths_sm_tiffs[[idx]])
st = read_stars(paths_sm_tiffs[[idx]])
st
plot(st)
st[spatial.obj]
r = st[spatial.obj]
r[[]]
r[[1]]
dim(r)
paths_sm_tiffs[[idx]]
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[idx]])
spatial.obj = st_buffer(spatial.obj, point_buffer)
plot(spatial.obj[[0]])
plot(spatial.obj[0])
aggre_dun
aggre_fun
matched_raster
res = exact_extract(matched_raster,
spatial.obj)
res
raster::writeRaster(matched_raster, "../testraster.tif")
library(sf)
st_write(spatial.obj, "../testspatialobj.gpkg")
point_buffer
spatial.obj
i
# get the actual spatial object
spatial.obj = landsld[i,]
spatial.obj = st_buffer(spatial.obj, point_buffer)
spatial.obj
res = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
res
dim(res)
# get the actual spatial object
spatial.obj = landsld[i,]
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
dim(res)
devtools::load_all()
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
dim(res)
class(res)
View(res)
landsld[["sm_values"]][[i]] = res
devtools::load_all()
library(iffitoR)
landsld = landsld[grepl("trans|rota", landsld$second_level), ]
dim(landsld)
path_sm
days_before_window = 5
days_after_window = 0
point_buffer = NULL
aggre_fun = NULL
quiet = TRUE
# check if the landsld data is available and has a date column ------------
landsld = check_date(landsld)
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
# if we have points and no buffer
point = checkpoint(type, point_buffer)
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
# if there are no files ---------------------------------------------------
if(length(paths_sm_tiffs) == 0){
stop("There are no files at the path you provided...")
}
# read the first file and compare the crs to the vector geometry
p = list.files(path_sm, full.names = T)[[1]]
f = read_stars(p)
p
f
# get the dates, tracks, times, swaths
dates = get_dates(paths_sm_tiffs)
tracks = get_tracks(paths_sm_tiffs)
swaths = get_swath(paths_sm_tiffs)
# this returns a Poixct object --> lubridate handles it!
times = get_time(paths_sm_tiffs)
times
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
landsld
dim(landsld)
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 6
# get the date of the slide
date_slide = landsld[i,]$date
# range of days around landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = times[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
library(iffitoR)
landsld %>% filter(
year.int > 2015,
year.int < 2018,
date_info == "day"
) -> l
library(tidyverse)
landsld %>% filter(
year.int > 2015,
year.int < 2018,
date_info == "day"
) -> l
dim(l)
path_sm
res = soilmoistr::get_sm_data(
landsld = l,
path_sm = path_sm,
days_before_window = 10
)
landsld %>% filter(
year.int > 2015,
year.int < 2018,
date_info == "day"
) %>%
slice(1:10)-> l
dim(l)
res = soilmoistr::get_sm_data(
landsld = l,
path_sm = path_sm,
days_before_window = 10
)
res
dim(res)
names(res)
hist(res$sm_values)
str(res)
l
library(iffitoR)
library(tidyverse)
landsld %>% filter(
year.int > 2015,
year.int < 2018,
date_info == "day"
) %>%
slice(1:10)-> l
landsld %>% filter(
year.int > 2015,
year.int < 2018,
date_info == "day"
) %>%
slice(1:3)-> l
res = soilmoistr::get_sm_data(
landsld = l,
path_sm = path_sm,
days_before_window = 10
)
l$date
unique(res$date)
a = res$sm_values
a
