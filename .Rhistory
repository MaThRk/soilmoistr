matched_raster = raster(paths_sm_tiffs[[i]])
aggre_fun
poly_extraction = exact_extract(matched_raster,
landsld,
force_df = TRUE) %>%
.[[1]] %>%
mutate(date_sm_acquisition = match)
match
poly_extraction = exact_extract(matched_raster,
landsld,
force_df = TRUE)
poly_extraction
matched_raster
landsld
spatial.obj
lansld = spatial.obj
poly_extraction = exact_extract(matched_raster,
landsld,
force_df = TRUE) %>%
.[[1]] %>%
mutate(date_sm_acquisition = match)
poly_extraction = exact_extract(matched_raster,
landsld,
force_df = TRUE)
poly_extraction
landsld
landsld = spatial.obj
landsld
poly_extraction = exact_extract(matched_raster,
landsld,
force_df = TRUE)
poly_extraction
matched_raster
landsld
plot(matched_raster)
matched_raster
plot(matched_raster)
# load the tif as raster
matched_raster = raster(paths_sm_tiffs[[i]])
matched_raster
plot(matched_raster)
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
j
lansld
library(iffitoR)
landsld
rm(list = c("landsld"))
landsld
dim(landsld)
sf::st_write(landsld, "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffitoR_extractiong.gpkg")
devtools::load_all()
a = get_sm_data(landsld = l, path_sm = path_sm)
l
l ="/mnt/CEPH_PROJECTS/Proslide/Landslides/iffitoR_extractiong.gpkg"
a = get_sm_data(landsld = l, path_sm = path_sm)
landsld = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffitoR_extractiong.gpkg"
# check if the landsld data is available and has a date column ------------
check_date(landsld)
# check if the landsld data is available and has a date column ------------
landsld = check_date(landsld)
landsld
landsld
landsld = "/mnt/CEPH_PROJECTS/Proslide/Landslides/iffitoR_extractiong.gpkg"
# check if the landsld data is available and has a date column ------------
landsld = check_date(landsld)
landsld[["date"]] = NULL
sf::st_write(landsld, "../testlandsldnodatecolumn.gpkg")
landsld = "../testlandsldnodatecolumn.gpkg"
# check if the landsld data is available and has a date column ------------
landsld = check_date(landsld)
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
rm(list = c("landsld"))
landsld
dim(landsld)
landsld = landsld[grepl("trans|rota", landsld$second_level), ]
dim(landsld)
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
type
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
# if there are no files ---------------------------------------------------
if(length(paths_sm_tiffs) == 0){
stop("There are no files at the path you provided...")
}
# read the first file and compare the crs to the vector geometry
p = list.files(path_sm, full.names = T)[[1]]
f = read_stars(p)
if(!(st_crs(f) == st_crs(landsld))){
stop("The CRS of the landsld-argument is not the same as the soilmoisture data")
}
# get the dates, tracks, times, swaths
dates = get_dates(paths_sm_tiffs)
tracks = get_tracks(paths_sm_tiffs)
swaths = get_swath(paths_sm_tiffs)
# this returns a Poixct object --> lubridate handles it!
times = get_time(paths_sm_tiffs)
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 1
# get the date of the slide
date_slide = landsld[i,]$date
date_slide
i = 6
# get the date of the slide
date_slide = landsld[i,]$date
# range of days around landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = times[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
# if we have points and no buffer
point = checkpoint(landsld, point_buffer)
devtools::load_all()
# if we have points and no buffer
point = checkpoint(landsld, point_buffer)
point
point_buffer
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
j
# the day of the soilmoisture image
match = matches[[j]]
matches
match
# which soilmoisture image?
idx = which(times == match)
idx
# load the tif as raster
matched_raster = raster(paths_sm_tiffs[[i]])
matched_raster
# if we are orinally using points, we must here create the buffer around that point
if (!is.null(point_buffer)) {
spatial.obj = st_buffer(spatial.obj, point_buffer)
}
spatial.obj
poly_extraction = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE)
poly_extraction
match
class(match)
poly_extraction = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(date_sm_acquisition = match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
year
month = month(match)
if(nchar(month) == 1){
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
time
month
day
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[i]])
matched_raster
poly_extraction = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time)
point_extraction()
poly_extraction
aggre_fun = c("mean")
# if we aggregate
poly_extraction = exact_extract(matched_raster,
landsld,
fun = aggre_fun,
force_df = TRUE) %>%
mutate(date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time)
poly_extraction
# if we aggregate
poly_extraction = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
mutate(date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time)
poly_extraction
devtools::load_all()
devtools::load_all()
l
library(iffitoR)
landsld = landsld[grepl("trans|rota", landsld$second_level), ]
days_before_window = 5
days_after_window = 0
point_buffer = 200
aggre_fun = c("mean")
# check if the landsld data is available and has a date column ------------
landsld = check_date(landsld)
landsld
# check that the path to the tiffs has no slash at the end
last_char = substr(path_sm, nchar(path_sm), nchar(path_sm))
if(last_char == "/"){
path_sm = substr(path_sm, 1, nchar(path_sm) - 1)
}
# check if polygon or point
type = st_geometry_type(landsld, by_geometry = F) %>% as.character()
type
# if we have points and no buffer
point = checkpoint(landsld, point_buffer)
point
# if we have points and no buffer
point = checkpoint(type, point_buffer)
point
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
path_sm
path_sm = "/mnt/CEPH_PROJECTS/"
path_sm = "/mnt/CEPH_PROJECTS/Proslide/soilmoisture/32632/"
# get all the paths  ------------------------------------------------------
paths_sm_tiffs = list.files(path_sm, full.names = TRUE)
# if there are no files ---------------------------------------------------
if(length(paths_sm_tiffs) == 0){
stop("There are no files at the path you provided...")
}
# read the first file and compare the crs to the vector geometry
p = list.files(path_sm, full.names = T)[[1]]
f = read_stars(p)
if(!(st_crs(f) == st_crs(landsld))){
stop("The CRS of the landsld-argument is not the same as the soilmoisture data")
}
# get the dates, tracks, times, swaths
dates = get_dates(paths_sm_tiffs)
tracks = get_tracks(paths_sm_tiffs)
swaths = get_swath(paths_sm_tiffs)
# this returns a Poixct object --> lubridate handles it!
times = get_time(paths_sm_tiffs)
# subset the landslides to only the days ----------------------------------
landsld = landsld[!is.na(landsld$date),]
# create a column for the numner of matches and the actual soil moisture values
landsld[["n_matches"]] = NA
landsld[["sm_values"]] = vector("list", length(nrow(landsld)))
i = 6
# get the date of the slide
date_slide = landsld[i,]$date
# range of days around landsld
date_range_slides = seq(date_slide - days_before_window,
date_slide + days_after_window,
by = "day")
# images that are within that range
matches = times[dates %in% date_range_slides]
matches
# append the number of matches for that slide
landsld[["n_matches"]][[i]] = length(matches)
# get the actual spatial object
spatial.obj = landsld[i,]
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj,
paths_sm_tiffs,
matches,
tracks,
swaths,
point_buffer,
times,
aggre_fun)
res
matches
matches
length(matches)
aggre_fun
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
res
spatial.obj
paths_sm_tiffs
matches
tracks
swaths
point_buffer
times
aggre-
aggre_fun
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
values_match
j = 1
poly_extraction = function(spatial.obj,
paths_sm_tiffs,
matches,
tracks,
swaths,
point_buffer,
times,
aggre_fun) {
# create the list of values for each matches date that we will put in the sm_values list
values_match = vector("list", length = length(matches))
# for potentially multiple matches in that time frame
for (j in seq_along(1:length(matches))) {
# the day of the soilmoisture image
match = matches[[j]]
# which soilmoisture image?
idx = which(times == match)
# Get more information about this soilmoisture images
track = tracks[[idx]]
swath = swaths[[idx]]
year = year(match)
month = month(match)
if (nchar(month) == 1) {
month = paste0(0, month)
}
day = day(match)
hour = hour(match)
minute = minute(match)
second = second(match)
time = paste0(hour, "_", minute, "_", second)
# load the soilmoisture image as raster
matched_raster = raster(paths_sm_tiffs[[i]])
# if we were originally using points, we must here create the buffer around that point
if (!is.null(point_buffer)) {
spatial.obj = st_buffer(spatial.obj, point_buffer)
}
# extract the cell-values --> no aggregation
if (is.null(aggre_fun)) {
poly_extraction = exact_extract(matched_raster,
spatial.obj,
force_df = TRUE) %>%
.[[1]] %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
values_match[[j]] = poly_extraction
} else{
# if we aggregate
poly_extraction = exact_extract(matched_raster,
spatial.obj,
fun = aggre_fun,
force_df = TRUE) %>%
mutate(
date = as.Date(paste0(year, month, day), "%Y%m%d"),
track = track,
swath = swath,
time = time
)
# put it in the list
values_match[[j]] = poly_extraction
}
# stack all the extracted dfs to one
values_extraction = do.call("rbind", values_match)
# return the df
return(values_extraction)
}
}
debug(poly_extraction)
poly_extraction(spatial.obj,
paths_sm_tiffs,
matches,
tracks,
swaths,
point_buffer,
times,
aggre_fun)
spatial.obj
poly_extraction()
res
!
undebug(poly_extraction)
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
res
debug(poly_extraction)
poly_extraction(spatial.obj,
paths_sm_tiffs,
matches,
tracks,
swaths,
point_buffer,
times,
aggre_fun)
devtools::load_all()
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
undebug(poly_extraction)
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
res
devtools::load_all()
rm(list =c("poly_extraction"))
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
res
debug(poly_extraction)
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
j
res
values_match
res
values_match
undebug(poly_extraction)
devtools::load_all()
# WORKING WITH POLYGONS
res = poly_extraction(spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
point_buffer = point_buffer,
times = times,
aggre_fun = aggre_fun)
res
point_buffer = NULL
res = point_extraction(
spatial.obj = spatial.obj
,
paths_sm_tiffs = paths_sm_tiffs
,
matches = matches
,
tracks = tracks
,
swaths = swaths
,
date_time = times
,
point_buffer = point_buffer
,
aggre_fun = aggre_fun
)
res
devtools::load_all()
res = point_extraction(
spatial.obj = spatial.obj,
paths_sm_tiffs = paths_sm_tiffs,
matches = matches,
tracks = tracks,
swaths = swaths,
date_time = times)
res
